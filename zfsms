#!/bin/bash

# zfs user properties:
#	- wrappedkey:slot
#	- pbkdf2iters:slot
#	- keylocation:slot

# TODO: handle insufficient permessions cleanly
# TODO: add keyformat
typeset DEFAULT_SLOT='default'
typeset CIPHER='aes-256-ctr'
typeset DEFAULT_ITERS=350000

function main() {
	local subcmd="$1"
	shift
	case "$subcmd" in
	"convert")     convert     "$@" ;;
	"load-key")    load-key    "$@" ;;
	"add-key")     add-key     "$@" ;;
	"remove-slot") remove-slot "$@" ;;
	"remove-key")  remove-key  "$@" ;;
	"change-key")  change-key  "$@" ;;
	"list-slots")  list-slots  "$@" ;;
	"-h") ;&
	"--help") ;&
	"help")
		help
		exit 0
		;;
	"")
		help
		exit 1
		;;
	*)
		echo "Unknown subcommand '$subcmd'" >&2
		help
		exit 1
		;;
	esac
}

function help() {
	printf 'usage:\n'
	printf '\t%s convert [-s <slot>] [-L <keylocation>] <filesystem>\n' "$0"
	printf '\t%s load-key [-n] [-s <slot>] [-L <keylocation>] <filesystem>\n' "$0"
	printf '\t%s add-key -s <new slot> -u <existing slot> [-L <keylocation>] [-i <iters>] <filesystem>\n' "$0"
	printf '\t%s remove-slot -s slot <filesystem>\n' "$0"
	printf '\t%s remove-key [-o keylocation=value] <filesystem>\n' "$0"
	printf '\t%s change-key [-l] [-o keylocation@slot=value] [-o pbkdf2iters@slot=value] <filesystem>\n' "$0"
	printf '\t%s change-key -i [-l] <filesystem>\n' "$0"
	printf '\t%s list-slots <filesystem>\n' "$0"
}

################
# Sub commands #
################
function convert() {
	local keystatus
	local filesystem
	local slot
	local loc
	local iters
	local zkey
	local ukey
	local wrappedkey

	while getopts L:s: name; do
		case "$name" in
			'L') loc="$OPTARG" ;;
			's') slot="$OPTARG" ;;
			*)
				help >&2
				exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	filesystem="$1"
	if [[ -z "$filesystem" ]]; then
		echo 'Filesystem not specified.' >&2
		exit 1
	fi
	shift
	[[ $# -eq 0 ]] || echo "WARNING: '$1' and later arguments are ignored." >&2
	[[ -n "$slot" ]] || slot="$DEFAULT_SLOT"

	keystatus="$(zfs get -Ho value keystatus "$filesystem")" || exit 1
	encroot="$(zfs get -Ho value encryptionroot "$filesystem")" || exit 1

	if [[ '-' == "$keystatus" ]]; then
		echo "Dataset '$1' is not encrypted" >&2
		exit 1
	elif [[ 'unavailable' == "$keystatus" ]]; then
		echo "Key must be loaded to convert to a multisecret dataset" >&2
		exit 1
	elif [[ 'available' != "$keystatus" ]]; then
		echo "Unknown key status: $keystatus" >&2
		exit 1
	elif [[ "$filesystem" != "$encroot" ]]; then
		echo "Use the encryption root: $encroot" >&2
		exit 1
	fi

	[[ -n "$slot" ]] || slot=$DEFAULT_SLOT
	[[ -n "$loc" ]] || loc='prompt'
	ukey="$(get-user-key "$loc")"

	iters="$(zfs get -Ho value pbkdf2iters "$filesystem")"
	[[ 0 == "$iters" ]] && iters="$DEFAULT_ITERS"

	zkey="$(dd if=/dev/random status=none bs=32 count=1 | xxd -p -c 0)"

	wrap-and-add-key "$zkey" "$ukey" "$loc" "$slot" "$iters" "$filesystem"
	zfs change-key \
		-o keylocation=prompt \
		-o keyformat=hex \
		"$filesystem" \
		<<< "$zkey"
}

function load-key() {
	local filesystem
	local loc
	local noop='false'
	local slot
	local ukey
	local wrappedkey
	local zkey

	while getopts nL:s: name; do
		case "$name" in
			'L') loc="$OPTARG" ;;
			'n') noop='true' ;;
			's') slot="$OPTARG" ;;
			*)
				help
				exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	filesystem="$1"
	if [[ -z "$filesystem" ]]; then
		echo 'Filesystem not specified.' >&2
		exit 1
	fi
	shift
	if [[ $# != 0 ]]; then
	       	printf 'unrecognized argument "%s"\n' "$1" >&2
		exit 1
	fi

	[[ -n "$loc" ]] || loc='prompt'
	ukey="$(get-user-key "$loc")"

	# TODO: don't repeat work
	if [[ -z "$slot" ]]; then
		slot="$(match-slot "$filesystem" "$ukey")" || exit $?
	fi

	zkey="$(fetch-and-unwrap "$filesystem" "$ukey" "$slot")" || exit $?
	if $noop; then
		echo "$zkey" | zfs load-key -n "$filesystem"
	else
		echo "$zkey" | zfs load-key "$filesystem"
	fi
}

function add-key() {
	local slot # new slot
	local uslot # slot to unwrap from
	local filesystem
	local iters
	local wrappedkey
	local loc
	local key
	local zkey
	local old_user_key_location
	local old_user_key

	while getopts s:u:L:i: name; do
		case "$name" in
			's') slot="$OPTARG" ;;
			'u') uslot="$OPTARG" ;;
			'L') loc="$OPTARG" ;;
			'i') iters="$OPTARG" ;;
			'*')
				help
				exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	filesystem="$1"
	if [[ -z "$filesystem" ]]; then
		echo 'Filesystem not specified.' >&2
		exit 1
	fi
	shift
	# TODO: error out instead of warning
	[[ $# -eq 0 ]] || echo "WARNING: '$1' and later arguments are ignored." >&2
	if [[ -z "$slot" ]]; then
		echo 'New slot not specified.' >&2
		exit 1
	fi
	if [[ -z "$uslot" ]]; then
		echo 'Slot to unwrap zfs key from not specified.' >&2
		exit 1
	fi
	[[ -n "$iters" ]] || iters="$DEFAULT_ITERS"
	[[ -n "$loc" ]] || loc='prompt'

	printf 'Getting the user key for slot "%s"\n' "$uslot"
	old_user_key_location="$(zfs get \
		-Ho value \
		"keylocation:$uslot" \
		"$filesystem")"
	old_user_key="$(get-user-key "$old_user_key_location")"
	zkey="$(fetch-and-unwrap \
		"$filesystem" \
		"$old_user_key" \
		"$uslot")"

	key="$(get-user-key "$loc")"
	wrap-and-add-key "$zkey" "$key" "$loc" "$slot" "$iters" "$filesystem"
}

function remove-slot() {
	local slot
	local filesystem

	while getopts s: name; do
		case "$name" in
			's') slot="$OPTARG" ;;
			'*')
				help
				exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	filesystem="$1"
	if [[ -z "$filesystem" ]]; then
		echo 'Filesystem not specified.' >&2
		exit 1
	fi
	shift
	[[ $# -eq 0 ]] || echo "WARNING: '$1' and later arguments are ignored." >&2
	if [[ -z "$slot" ]]; then
		echo 'Slot to remove not specified.' >&2
		exit 1
	fi

	if [[ $(list-slots "$filesystem" | wc -l) -lt 2 ]]; then
		echo 'Refusing to remove last slot.' >&2
		exit 1
	fi

	zfs inherit "wrappedkey:$slot" "$filesystem"
	zfs inherit "pbkdf2iters:$slot" "$filesystem"
}

function remove-key() {
	local filesystem
	local keylocation
	local slot
	local user_key

	while getopts o: name; do
		case "$name" in
			'o') keylocation="$OPTARG" ;;
			'*')
				help
				exit 1
				;;
		esac
	done
	shift $((OPTIND - 1))
	filesystem="$1"
	if [[ -z "$filesystem" ]]; then
		echo 'Filesystem not specified.' >&2
		exit 1
	fi
	shift
	[[ $# -eq 0 ]] || echo "WARNING: '$1' and later arguments are ignored." >&2

	if [[ -z "$keylocation" ]]; then
		keylocation='prompt'
	fi
	user_key="$(get-user-key "$keylocation")"
	slot="$(match-slot "$filesystem" "$user_key")" || return 1
	if [[ -z "$slot" ]]; then
		echo 'No slot found matching key' >&2
		return 1
	fi
	remove-slot -s "$slot" "$filesystem"
}

function change-key() {
	while getopts lL:I: name; do
		:
	done
}

function list-slots() {
	if [[ 1 != "$#" ]]; then
		help
		exit 1
	fi

	typeset filesystem="$1"
	zfs get all "$filesystem" -Ho property \
		| grep wrappedkey \
		| cut -f 2 -d : \
		| sort
}

####################
# Helper functions #
####################

function wrap() {
	local zkey="$1"
	local ukey="$2"
	local iters="$3"

	echo "$zkey" \
		| openssl $CIPHER \
			-iter "$iters" \
			-pass "pass:$ukey" \
		| base64 -w 0
}

function unwrap() {
	local wrapped="$1"
	local ukey="$2"
	local iters="$3"

	key="$(echo "$wrapped" \
		| base64 -d \
		| openssl $CIPHER \
			-d \
			-iter "$iters" \
			-pass "pass:$ukey")"

	if [[ 64 != $(echo -n "$key" | wc -m) ]]; then
		return 1
	fi
	printf '%s' "$key"
}

function wrap-and-add-key() {
	local zkey="$1"
	local ukey="$2"
	local loc="$3"
	local slot="$4"
	local iters="$5"
	local filesystem="$6"
	local wrappedkey

	wrappedkey="$(wrap "$zkey" "$ukey" "$iters")"

	zfs set "pbkdf2iters:$slot=$iters" "$filesystem" || exit 1
	zfs set "wrappedkey:$slot=$wrappedkey" "$filesystem" || exit 1
	zfs set "keylocation:$slot=$loc" "$filesystem" || exit 1
}

function fetch-and-unwrap() {
	local filesystem="$1"
	local ukey="$2"
	local slot="$3"
	local iters
	local wrapped
	local zkey

	iters="$(zfs get -Ho value "pbkdf2iters:$slot" "$filesystem")" || exit 1
	if [[ '-' == "$iters" ]]; then
		echo "slot '$slot' malformed"  >&2
		exit 1
	fi
	wrapped="$(zfs get -Ho value "wrappedkey:$slot" "$filesystem")" || exit 1
	if [[ '-' == "$wrapped" ]]; then
		echo "slot '$slot' malformed"  >&2
		exit 1
	fi

	unwrap "$wrapped" "$ukey" "$iters"
}

# prints the slot, given key
function match-slot() {
	local filesystem="$1"
	local ukey="$2"
	local key
	for slot in $(list-slots "$filesystem"); do
		key="$(fetch-and-unwrap "$filesystem" "$ukey" "$slot")" || continue
		if zfs load-key -n "$filesystem" > /dev/null 2>&1 <<< "$key"; then
			printf '%s' "$slot"
			return 0
		fi
	done
	return 1
}

function get-user-key() {
	local keylocation="$1"
	local ukey

	case "$keylocation" in
	'prompt')
		if [[ -t 0 ]]; then
			read -s -r -p 'Enter passphrase: ' ukey
			printf '\n'
		else
			read -r ukey
		fi
		echo "$ukey"
		;;
	file://* | https://* | http://*)
		curl "$keylocation"
		;;
	*)
		printf 'Unknown key location: %s\n' "$keylocation" >&2
		return 1
		;;
	esac
}

# Only run the command if the script is not being sourced (as it would be for
# testing)
(return 0 2> /dev/null) || main "$@"

# vim: noexpandtab sts=8 sw=8 colorcolumn=81 textwidth=80 foldmethod=indent
